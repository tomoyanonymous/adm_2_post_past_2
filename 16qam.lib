import("stdfaust.lib");


global =environment {

  // delaytime in ms
  vel_c = 340.;
  bauds_per_band = 8;
  num_band = 3;
  baudrate = hslider("baudrate",500,100,800,0.1);
  delay_time = int((bauds_per_band/baudrate)*ma.SR);
  clock_duty = hslider("duty",0.75,0,1,0.01);
  //　一本のジェネレーターからキャリアを生成する場合、base_carrierの整数倍になる
  base_carrier = 300;
  freq_list = par(i,num_band,(i+1)*base_carrier);
  frequency(index) = ba.take(index+1,freq_list);

  dem_rolloff_order = 4;
  dem_rolloff_rate = hslider("dem_rolloffrate",500,100,800,0.1);
  mod_rolloff_order = 4;
  mod_rolloff_rate = hslider("mod_rolloffrate",500,100,800,0.1);
  switchtraining = checkbox("Training");
  PLLrate = hslider("PLLrate",1,0.01,15,0.01);
  PLLrate_training = hslider("PLLrate_training",2,0.01,15,0.01);
  PLL_rate = select2(switchtraining,PLLrate,PLLrate_training);
  debug_num = hslider("debugBand",1,1,num_band,1);
  prefilter_order = 3;
};


// ---------------demodulation section



// demodulator(carrier,phaseerror,input) = (input,((carrier+deltaphase):carrierphasor) )<:(cosmod,sinmod)
// with {
//   deltaphase = phaseerror:fi.lowpass(1,global.PLL_rate);
//   // tablesize = 1<<16;
//   carrierphasor = os.lf_sawpos;
//   sinwave = *(ma.PI*2):sin;
//   coswave = *(ma.PI*2):cos;
//   sinmod(input,carrierphase) = (carrierphase:sinwave:*(input)):*(2):fi.lowpass(global.dem_rolloff_order,global.dem_rolloff_rate);
//   cosmod(input,carrierphase) = (carrierphase:coswave:*(input)):*(2):fi.lowpass(global.dem_rolloff_order,global.dem_rolloff_rate);
// };
demodulator(phase,input) = (input,phase)<:(cosmod,sinmod)
with {
  sinwave = *(ma.PI*2):sin;
  coswave = *(ma.PI*2):cos;
  sinmod(input,carrierphase) = (carrierphase:sinwave:*(input)):*(2):fi.lowpass(global.dem_rolloff_order,global.dem_rolloff_rate);
  cosmod(input,carrierphase) = (carrierphase:coswave:*(input)):*(2):fi.lowpass(global.dem_rolloff_order,global.dem_rolloff_rate);
};

demodulator_mobile(phase,input) = demodulator(phase,input);
// ----------------sampling section
clockdatarecovery(rate) = fi.highpass(1,rate*0.8):abs:fi.resonbp(rate,1000,1):(>(0));
sample_clock(rate) = os.lf_sawpos(rate);

sampler(clock) =(ba.latch(c),ba.latch(c))
with {
    c = clock:(>(global.clock_duty));
};
sampler_self(rate,in1,in2) = (in1,in2):sampler(clock_self)
with{
  clock_self = (in1,in2):(clockdatarecovery(rate),clockdatarecovery(rate)):>_;
};

// ---------------decide section

decider = decide_mono,decide_mono
with {
decide_mono = _<:(abs,_):(>(2/3),>(0));
};

pilot_table1 = waveform{1,1,0},_:rdtable;
pilot_table2 = waveform{1,0,0},_:rdtable;

pilot_decider = (pilot_mono,pilot_mono)<:(&,(|:bitinv:*(2)),(xor:*(3))):>-(1):int<:(pilot_table1,1,pilot_table2,1)
with{
  bitinv(x) = 1- x;
  pilot_mono= _:abs:(>(2/3));
};
// -------pilot tone section

pilot_tone(bauds_per_band,clock) = clock:pilot_reader<:(pilot_table1,1,pilot_table2,1)
with{
  count_negedge(length,clock) = (clock-(clock:mem)):(<(0)):((+:fmod(length))~(_));
  count_threshold(length,threshold,clock) = ((>=(clock,threshold)),(<(clock',threshold))):(&):((+:modulo(length))~(_));
  modulo(len) = /(len):ma.decimal:*(len):int;
  pilot_reader = count_threshold(bauds_per_band,0.5)<:((modulo(2):*(-1):+(1)),(>(0))):*:int;
};

// ---------training section
training_sequence(clock) = par(i,4,count_offset(clock*(-1),size,size*i):bitnoisetable)
with {
  bitnoisetable(input) = rdtable(size*4,no.noise,int(input)):(>(0));
  size = 1<<16 ;
  count_posedge(clock,length) = (clock-(clock:mem)):(>(0)):(+~_):(fmod(length));
  count_offset(clock,length,offset) = count_posedge(clock,length)+offset;
};
switchbits(bit1,bit2,bit3,bit4,tbit1,tbit2,tbit3,tbit4) = (sbit1,sbit2,sbit3,sbit4)
with{
  selbit(bit,tbit) = select2(global.switchtraining,bit,tbit);
  sbit1=selbit(bit1,tbit1);
  sbit2=selbit(bit2,tbit2);
  sbit3=selbit(bit3,tbit3);
  sbit4=selbit(bit4,tbit4);
};

// ----------------remapper section

remapper(bit1,bit2,bit3,bit4) = remapper_mono(bit1,bit2),remapper_mono(bit3,bit4)
with {
  bitscale(bmin,bmax) = *(bmax-bmin)+bmin;
  remapper_mono(b1,b2) =(b1:bitscale(1/3,1) ) * ( b2:bitscale(-1,1) );
};

//  ---------------rolloff baseband signal

rolloff = rolloff_mono,rolloff_mono
with {
  rolloff_mono = fi.lowpass(global.mod_rolloff_order,global.mod_rolloff_rate);
};

//  ---------------modulator
multiphasor(base_freq,band_num) = base_freq:os.lf_sawpos<:par(i,band_num,(*(i+1):fmod(1.)));
multiphasor_pll(base_freq,band_num,phaseerror) = (base_freq+deltaphase):os.lf_sawpos<:par(i,band_num,(*(i+1):fmod(1.)))
with{
  deltaphase = phaseerror:fi.lowpass(1,global.PLL_rate);
};

modulator(phase,in1,in2) = phase<:(coswave,sinwave):(*(in1),*(in2)):+
with {
  // modcarrierphasor = os.lf_sawpos(carrier);
  // tablesize = 1<<16;
  sinwave = *(ma.PI*2):sin;
  coswave = *(ma.PI*2):cos;
};


//  ---------------caluculate phaseerror section
// average(n) = (si.bus(n):>_):/(n);


compute_phaseerror(cos1,sin1,cos2,sin2)=atan2(cos1,sin1)-atan2(cos2:trainingdelay,sin2:trainingdelay)
with {
  trainingdelay = @(global.switchtraining*global.delay_time);
};

// automatic gain controllable
autogain(input) = input/(gain_ratio+0.001)
  with {
    correct = hslider("gain",0.707,0,1,0.01);
    inv_min(minus) = (minus,_):-;
    estimate_gain=(_<:(*)):sqrt:fi.lowpass(1,hslider("agc_rate",5,0.1,100,0.01));
    gain_ratio = ((input:estimate_gain)/(correct+0.00001)):switchgain(global.switchtraining);
    switchgain(c,x) = (c*x):(+~(*(1-c)));
  };

//-----------prefilter
prefilter(carrier,baudrate) = fi.lowpass(global.prefilter_order,carrier+baudrate+10):fi.highpass(global.prefilter_order,carrier-baudrate-10);

//---------------------------------release section
qam_pilot(carrier,baudrate,dem_phase,mod_phase,input,clock) = ( ((dem_phase,(input:prefilter(carrier,baudrate):autogain)):demodulator ),(clock:pilot_tone(global.bauds_per_band):remapper:rolloff<:si.bus(4))):(compute_phaseerror,((mod_phase,_,_):modulator));

qam_single(carrier,baudrate,dem_phase,mod_phase,input,clock) = (dem_phase,(input:prefilter(carrier,baudrate):autogain)):demodulator:((_,_,clock):sampler:decider:remapper:rolloff:(mod_phase,_,_):modulator);

qam = case{

  (0,carrier,baudrate,dem_phase,mod_phase,input,clock) => qam_pilot(carrier,baudrate,dem_phase,mod_phase,input,clock);

  (index,carrier,baudrate,dem_phase,mod_phase,input,clock)=> qam_single(carrier,baudrate,dem_phase,mod_phase,input,clock);
};

qam_multi(base_freq,num_band,baudrate,phase_error,input) = ((phase_error:multiphasor_pll(base_freq,num_band)),multiphasor(base_freq,num_band),(input<:si.bus(num_band)),(sample_clock(baudrate)<:si.bus(num_band)) )<:ro.interleave(num_band,4):par(i,num_band,(qam(i,global.frequency(i),global.baudrate))):(_,(si.bus(num_band):>_));

//--------------------debug section

debug_bus(this_band_num,debug_num) = par(i,6,*(isSelected(this_band_num,debug_num)))
with {
  isSelected(x,y) = (x,y):==;
};

qam_pilot_debug(index,carrier,baudrate,dem_phase,mod_phase,input,clock) = ((dem_phase,(input:prefilter(carrier,baudrate):autogain)):demodulator)<:(si.bus(2),(clock:pilot_tone(global.bauds_per_band):remapper<:si.bus(4)),si.bus(2)):(si.bus(2),(rolloff<:si.bus(6)),si.bus(4)):(compute_phaseerror,((mod_phase,_,_):modulator),debug_bus(index,global.num_band));


qam_single_debug(index,carrier,baudrate,dem_phase,mod_phase,input,clock) = ((dem_phase,(input:prefilter(carrier,baudrate):autogain)):demodulator)<:((((_,_,clock):sampler)<:si.bus(4)),si.bus(2)) :(((decider:remapper:rolloff)<:si.bus(4)),si.bus(4)):(((mod_phase,_,_):modulator),debug_bus(index,global.num_band));

qam_debug = case{

  (0,carrier,baudrate,dem_phase,mod_phase,input,clock) => qam_pilot_debug(0,carrier,baudrate,dem_phase,mod_phase,input,clock);

  (index,carrier,baudrate,dem_phase,mod_phase,input,clock)=> qam_single_debug(index,carrier,baudrate,dem_phase,mod_phase,input,clock);
};

qam_multi_debug(base_freq,num_band,baudrate,clock,phase_error,input) = ((phase_error:multiphasor_pll(base_freq,num_band)),multiphasor(base_freq,num_band),(input<:si.bus(num_band)),(clock<:si.bus(num_band)))<:ro.interleave(num_band,4):par(i,num_band,(qam_debug(i,global.frequency(i),global.baudrate))):(_,(si.bus(7*num_band):>si.bus(7)),clock);

// ---------select by isDebug(0:release,1:Debug)
// process_pre =
// case{
//   (0) => qam_multi;
//   (1) => (_,sample_clock(global.baudrate)):qam_multi_debug;
// };
//
// process =process_pre(global.isDebug);
